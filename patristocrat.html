<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Codebusters Patristocrat cipher practice">
    <title>Patristocrat Practice</title>
    <!-- We will use the common styles.css structure but embed specific styles -->
    <link rel="stylesheet" href="styles.css">
    <style>
        /* Specific Styles for Patristocrat Layout */
        .puzzle-container {
            max-width: 900px;
            margin: auto;
            background: #fff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .puzzle-container h1 {
            text-align: center;
            color: #007bff;
            margin-bottom: 25px;
        }

        /* Styling for the 5-letter blocks, which are the core visual difference */
        .puzzle-grid {
            border: 2px solid #ccc;
            padding: 20px 10px;
            margin-bottom: 20px;
            border-radius: 8px;
            background-color: #eee;
            line-height: 1.8;
            font-size: 0; /* Important: collapse space between inline-blocks */
            text-align: center;
        }

        .patristocrat-block {
            display: inline-block;
            margin: 0 10px 15px 10px; /* Space between 5-letter groups */
        }
        
        .letter-pair {
            display: inline-flex; 
            flex-direction: column;
            align-items: center;
            margin: 0 1px; /* Tighter spacing within a 5-letter group */
            text-align: center;
            font-size: 1rem; /* Re-establish font size for children */
        }

        .cipher-char {
            font-size: 1.3rem; 
            font-weight: bold;
            font-family: monospace;
            padding: 0 2px;
            min-width: 25px; 
        }

        .plain-input {
            width: 25px;
            height: 25px;
            padding: 0;
            text-align: center;
            font-size: 1.2rem;
            border: 1px solid #007bff;
            border-radius: 4px;
            text-transform: uppercase;
            margin-top: 2px;
        }

        /* Utility styles for the control panel */
        .substitution-area {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #ddd;
        }
        #new-puzzle-button, #clear-button, #give-up-button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            font-weight: bold;
        }
        #new-puzzle-button { background-color: #28a745; color: white; }
        #new-puzzle-button:hover { background-color: #1e7e34; }
        #clear-button { background-color: #ffc107; color: #333; }
        #clear-button:hover { background-color: #e0a800; }
        #give-up-button { background-color: #dc3545; color: white; }
        #give-up-button:hover { background-color: #c82333; }

        /* Mapping Table Styles (Reused from Aristocrat) */
        .mapping-table {
            margin-top: 30px;
            text-align: center;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background-color: #f9f9f9;
        }
        .mapping-table h3 {
            margin-top: 0;
            color: #007bff;
        }
        .mapping-grid {
            display: flex;
            flex-direction: column;
            margin-top: 15px;
            border: 1px solid #ccc;
            border-radius: 6px;
            overflow: hidden;
        }
        .mapping-row {
            display: grid;
            grid-template-columns: 60px repeat(26, 1fr); 
            gap: 1px; 
            border-bottom: 1px solid #ddd;
        }
        .mapping-label {
            background-color: #e9ecef;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: flex-end; 
            padding-right: 5px;
            font-size: 0.8rem;
            color: #333;
        }
        .mapping-cell {
            padding: 5px 2px;
            text-align: center;
            font-family: monospace;
            font-size: 0.9rem;
            font-weight: bold;
            border-left: 1px solid #eee;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .frequency-row { background-color: #e6f7ff; }
        /* Adjusted font size for count to match Aristocrat look */
        .frequency-row .mapping-cell { font-weight: normal; font-size: 0.9rem; color: #007bff; }
        .cipher-row { background-color: #fff; }
        /* Plain row content should be uppercase and visible */
        .plain-row { background-color: #fff; color: #333; font-size: 1rem; }
    </style>
</head>
<body>
    <!-- Header (Using styles from styles.css) -->
    <header>
        <div class="container">
            <a href="index.html" class="logo">Codebusters</a>
            <nav>
                <ul>
                    <li><a href="aristocrat.html">Aristocrat</a></li>
                    <li><a href="patristocrat.html">Patristocrat</a></li>
                    <li><a href="baconian.html">Baconian</a></li>
                    <li><a href="xenocrypt.html">Xenocrypt</a></li>
                    <li><a href="porta.html">Porta</a></li>
                    <li><a href="cryptarithm.html">Cryptarithm</a></li>
                    <li><a href="nihilist.html">Nihilist</a></li>
                    <li><a href="columnar.html">Columnar</a></li>
                    <li><a href="morse.html">Fractionated Morse</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main>
        <div class="container">
            <div class="puzzle-container">
                <h1>Patristocrat Cipher Practice</h1>
                <p class="text-center">A substitution cipher with no word divisions, grouped into 5-letter blocks.</p>
                
                <div class="substitution-area">
                    <button id="new-puzzle-button">Generate New Cipher</button>
                    <button id="clear-button">Clear All Guesses</button>
                    <button id="give-up-button">Give Up / Show Solution</button>
                </div>

                <h2>Ciphertext (5-Letter Groups):</h2>
                <div id="puzzle-grid-display" class="puzzle-grid">
                    <!-- Cipher letters and input boxes will be rendered here -->
                </div>

                <div id="mapping-table" class="mapping-table">
                    <h3>Cipher Alphabet Map & Frequency</h3>
                    <div id="mapping-grid" class="mapping-grid">
                        <!-- Mappings and frequency will be displayed here -->
                    </div>
                </div>

                <p id="message-area" style="font-weight: bold; text-align: center; margin-top: 20px;"></p>
            </div>
        </div>
    </main>

    <script>
        // --- Patristocrat-Specific JS Logic ---

        const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const PUZZLES = [
            // Note: Quotes are kept short and clean for initial Patristocrat form
            "CRYPTOGRAPHY IS THE ART OF WRITING OR SOLVING CODES",
            "THE PATRISTOCRAT IS A CIPHER WITHOUT WORD DIVISIONS",
            "FREQUENT LETTERS IN ENGLISH INCLUDE E T A O I N S H R",
            "A GOOD CRYPTOGRAPHER IS ALWAYS ONE STEP AHEAD OF THE SOLVER",
            "CHALLENGING PUZZLES ARE THE BEST WAY TO PRACTICE CIPHERS"
        ];

        let currentCiphertext = '';
        let currentPlaintext = ''; // The full unencrypted quote
        let originalMapping = {};    // The correct key (Cipher -> Plain)
        let userSubstitutions = {};  // User's current guesses (Cipher -> Plain)
        let frequencyMap = {};       // Frequency of cipher characters

        const puzzleGridDisplay = document.getElementById('puzzle-grid-display');
        const mappingGrid = document.getElementById('mapping-grid');
        const messageArea = document.getElementById('message-area');
        const newPuzzleButton = document.getElementById('new-puzzle-button');
        const clearButton = document.getElementById('clear-button');
        const giveUpButton = document.getElementById('give-up-button');

        document.addEventListener('DOMContentLoaded', () => {
            newPuzzleButton.addEventListener('click', generateNewPuzzle);
            clearButton.addEventListener('click', clearGuesses);
            giveUpButton.addEventListener('click', showSolution);
            generateNewPuzzle();
        });

        // --- Core Cipher Functions ---

        /**
         * Cleans plaintext, removing spaces and punctuation, converts to uppercase.
         * @param {string} text - The original text.
         * @returns {string} The normalized text for encryption.
         */
        function normalizePlaintext(text) {
            return text.toUpperCase().replace(/[^A-Z]/g, '');
        }

        /**
         * Generates a random substitution map (a simple shuffle of the alphabet).
         * @returns {Object} { CipherChar: PlainChar }
         * @returns {Object} { PlainChar: CipherChar }
         */
        function generateRandomMapping() {
            const plain = ALPHABET.split('');
            const cipher = [...plain].sort(() => Math.random() - 0.5); // Shuffle
            
            const pToC = {}; // Plain to Cipher
            const cToP = {}; // Cipher to Plain (what we use for solving/checking)

            plain.forEach((p, index) => {
                pToC[p] = cipher[index];
                cToP[cipher[index]] = p;
            });
            
            // Reversing it is necessary because Aristocrats must always have a full 26-letter mapping, 
            // even if not all letters appear in the puzzle.
            return cToP; 
        }

        /**
         * Encrypts the normalized plaintext using the given mapping.
         * @param {string} plainText - The normalized plaintext (only A-Z).
         * @param {Object} mapping - The { PlainChar: CipherChar } map.
         * @returns {string} The ciphertext.
         */
        function encrypt(plainText, mapping) {
             const cToP_reversed = {};
             for (const [cipher, plain] of Object.entries(mapping)) {
                cToP_reversed[plain] = cipher;
            }

            let cipher = '';
            for (const char of plainText) {
                cipher += cToP_reversed[char];
            }
            return cipher;
        }

        /**
         * Formats the raw ciphertext into 5-letter groups. This is the Patristocrat defining feature.
         * @param {string} rawCiphertext - The full A-Z ciphertext with no spaces.
         * @returns {string} The ciphertext formatted with spaces every 5 characters.
         */
        function formatPatristocrat(rawCiphertext) {
            let formatted = '';
            for (let i = 0; i < rawCiphertext.length; i++) {
                formatted += rawCiphertext[i];
                if ((i + 1) % 5 === 0 && (i + 1) < rawCiphertext.length) {
                    formatted += ' ';
                }
            }
            return formatted;
        }


        /**
         * Calculates character frequency for the ciphertext.
         */
        function calculateFrequency(cipher) {
            const freq = {};
            for (const char of ALPHABET) {
                freq[char] = 0;
            }
            for (const char of cipher) {
                if (ALPHABET.includes(char)) {
                    freq[char] = (freq[char] || 0) + 1;
                }
            }
            // Store only the count
            const finalFreq = {};
            for (const char in freq) {
                finalFreq[char] = { count: freq[char] };
            }
            return finalFreq;
        }

        // --- UI Rendering Functions ---

        /**
         * Renders the puzzle grid with ciphertext and input boxes.
         */
        function renderPuzzleGrid() {
            puzzleGridDisplay.innerHTML = '';
            const formattedCiphertext = formatPatristocrat(currentCiphertext);
            
            // Loop through blocks (5-letter groups separated by space)
            const blocks = formattedCiphertext.split(' ');

            blocks.forEach(block => {
                if (!block) return; // Skip empty blocks

                const blockDiv = document.createElement('div');
                blockDiv.className = 'patristocrat-block';

                for (let i = 0; i < block.length; i++) {
                    const cipherChar = block[i];
                    
                    const pairDiv = document.createElement('div');
                    pairDiv.className = 'letter-pair';

                    // Cipher Character (Top Row)
                    const cipherSpan = document.createElement('span');
                    cipherSpan.className = 'cipher-char';
                    cipherSpan.textContent = cipherChar;

                    // Plaintext Input (Bottom Row)
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.maxLength = 1;
                    input.className = 'plain-input';
                    input.setAttribute('data-cipher', cipherChar);
                    
                    // Set initial value from current guesses
                    input.value = userSubstitutions[cipherChar] || '';

                    // Add event listener for input change
                    input.addEventListener('input', handleInput);
                    
                    pairDiv.appendChild(cipherSpan);
                    pairDiv.appendChild(input);
                    blockDiv.appendChild(pairDiv);
                }
                puzzleGridDisplay.appendChild(blockDiv);
            });
            
            // Re-apply existing guesses after rendering
            updateAllInputs();
            checkSolution();
        }

        /**
         * Renders the alphabet mapping and frequency table in the order: Count, Cipher, Plain.
         */
        function renderMappingTable() {
            mappingGrid.innerHTML = '';
            
            // 1. Frequency Row (Count)
            const freqRow = document.createElement('div');
            freqRow.className = 'mapping-row frequency-row';
            freqRow.innerHTML = `<div class="mapping-label">Count:</div>`;

            // 2. Cipher Row
            const cipherRow = document.createElement('div');
            cipherRow.className = 'mapping-row cipher-row';
            cipherRow.innerHTML = `<div class="mapping-label">Cipher:</div>`;
            
            // 3. Plain Guess Row
            const plainRow = document.createElement('div');
            plainRow.className = 'mapping-row plain-row';
            plainRow.innerHTML = `<div class="mapping-label">Plain:</div>`;
            
            // Build the cells for all rows
            for (const char of ALPHABET) {
                // Count Row
                const freqData = frequencyMap[char] || { count: 0 };
                freqRow.innerHTML += `<div class="mapping-cell">${freqData.count}</div>`;

                // Cipher Row (The letters being substituted)
                cipherRow.innerHTML += `<div class="mapping-cell">${char}</div>`;
                
                // Plain Guess Row (What the user has mapped the cipher char to, using '_' placeholder)
                plainRow.innerHTML += `<div id="plain-map-${char}" class="mapping-cell">${userSubstitutions[char] || '_'}</div>`;
            }

            // Append in the desired order: Count, Cipher, Plain
            mappingGrid.appendChild(freqRow);
            mappingGrid.appendChild(cipherRow);
            mappingGrid.appendChild(plainRow);
        }

        // --- Interaction Functions ---

        /**
         * Handles user input into any plaintext input box.
         * @param {Event} event - The input event.
         */
        function handleInput(event) {
            const input = event.target;
            let plainChar = input.value.toUpperCase();
            const cipherChar = input.getAttribute('data-cipher');

            // 1. Sanitize input
            if (!ALPHABET.includes(plainChar)) {
                plainChar = '';
            }

            // 2. Check for conflicts
            const existingCipherChar = Object.keys(userSubstitutions).find(key => userSubstitutions[key] === plainChar);

            if (plainChar && existingCipherChar && existingCipherChar !== cipherChar) {
                // Conflict found: PlainChar is already mapped to a DIFFERENT CipherChar
                messageArea.textContent = `Error: The letter ${plainChar} is already mapped to cipher letter ${existingCipherChar}. Clear that mapping first.`;
                input.value = ''; // Clear current input
                return;
            }

            // 3. Update internal state (userSubstitutions)
            if (plainChar) {
                userSubstitutions[cipherChar] = plainChar;
                messageArea.textContent = ''; // Clear previous error
            } else {
                delete userSubstitutions[cipherChar];
            }

            // 4. Update all related UI elements
            updateAllInputs(cipherChar, plainChar);
            checkSolution();
        }

        /**
         * Updates all input fields and the mapping table based on the new substitutions.
         */
        function updateAllInputs(changedCipherChar, newPlainChar) {
            // Update all input boxes for the changed substitution
            document.querySelectorAll('.plain-input').forEach(input => {
                const cipherChar = input.getAttribute('data-cipher');
                
                // Set the input value based on the current map
                input.value = userSubstitutions[cipherChar] || '';
            });

            // Update the mapping table cells
            for (const char of ALPHABET) {
                const mapCell = document.getElementById(`plain-map-${char}`);
                if (mapCell) {
                     // Use underscore as placeholder
                     mapCell.textContent = userSubstitutions[char] || '_';
                }
            }

            // Special case for conflict resolution (clear the old input if conflict was resolved by setting a new value)
             if (newPlainChar) {
                const oldCipher = Object.keys(userSubstitutions).find(key => 
                    key !== changedCipherChar && userSubstitutions[key] === newPlainChar
                );
                if (oldCipher) {
                    delete userSubstitutions[oldCipher];
                    // Recursively update everything to clear the input for the old cipher char
                    updateAllInputs(); 
                }
            }
        }


        /**
         * Checks if the current user substitutions match the original puzzle mapping.
         */
        function checkSolution() {
            let solved = true;
            for (const char of currentCiphertext) {
                if (ALPHABET.includes(char)) {
                    // Only check letters that are actually in the puzzle
                    if (originalMapping[char] && userSubstitutions[char] !== originalMapping[char]) {
                        solved = false;
                        break;
                    }
                }
            }

            if (solved && currentCiphertext.length > 0 && Object.keys(userSubstitutions).length >= Object.keys(originalMapping).length) {
                messageArea.textContent = 'SOLVED! Congratulations! Click "New Cipher" to continue practicing.';
                messageArea.style.color = '#28a745';
                // Disable inputs
                document.querySelectorAll('.plain-input').forEach(input => input.disabled = true);
            } else {
                messageArea.textContent = 'Keep decoding...';
                messageArea.style.color = '#007bff';
            }
        }

        /**
         * Resets the game state and generates a new Patristocrat puzzle.
         */
        function generateNewPuzzle() {
            const quoteIndex = Math.floor(Math.random() * PUZZLES.length);
            currentPlaintext = normalizePlaintext(PUZZLES[quoteIndex]);
            originalMapping = generateRandomMapping();
            currentCiphertext = encrypt(currentPlaintext, originalMapping);
            userSubstitutions = {};
            frequencyMap = calculateFrequency(currentCiphertext);
            
            // Re-enable inputs
            document.querySelectorAll('.plain-input').forEach(input => input.disabled = false);

            renderPuzzleGrid();
            renderMappingTable();
            checkSolution();
        }

        /**
         * Clears all user guesses (substitutions).
         */
        function clearGuesses() {
            userSubstitutions = {};
            messageArea.textContent = 'Guesses cleared. Start fresh!';
            messageArea.style.color = '#6c757d';
            updateAllInputs();
            checkSolution();
            // Re-enable inputs
            document.querySelectorAll('.plain-input').forEach(input => input.disabled = false);
        }

        /**
         * Reveals the final solution mapping.
         */
        function showSolution() {
            userSubstitutions = { ...originalMapping };
            messageArea.textContent = 'Solution revealed. The correct plaintext is now visible in the inputs.';
            messageArea.style.color = '#dc3545';
            updateAllInputs();
            checkSolution(); // Will confirm solved state
        }

    </script>

</body>
</html>